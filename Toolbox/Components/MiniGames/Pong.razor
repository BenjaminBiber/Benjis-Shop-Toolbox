@using System.Threading
@using Microsoft.AspNetCore.Components.Web
@using System.Globalization
@using Toolbox.Components.Dialogs
@inject IDialogService DialogService
@inject EasterEggService EasterEggService
@implements IDisposable

<MudPaper Class="pong-card pa-4" Elevation="3">
    <div class="d-flex justify-content-between flex-wrap align-items-center gap-2 mb-2">
        <MudText Typo="Typo.h5" Class="mb-0">Pong Trainingsfeld</MudText>
    </div>

    <div class="pong-board" tabindex="0" @ref="_boardRef" @onkeydown="OnKeyDown" @onkeydown:preventDefault="true" @onkeyup="OnKeyUp" @onclick="FocusBoard">
        <div class="pong-net"></div>
        <div class="pong-ball" style="@GetBallStyle()"></div>
        <div class="pong-paddle" style="@GetPaddleStyle()"></div>
        @if (!Running)
        {
            <div class="pong-hint">
                <MudText Typo="Typo.body2" Class="mb-1">Space startet das Spiel.</MudText>
                <MudText Typo="Typo.caption">Steuerung mit ←/A und →/D.</MudText>
            </div>
        }
    </div>

    <div class="d-flex flex-wrap align-items-center gap-2 mt-3">
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="StartGame">Start / Resume</MudButton>
        <MudButton Color="Color.Default" Variant="Variant.Outlined" Disabled="@(!Running)" OnClick="PauseGame">Pause</MudButton>
        <MudButton Color="Color.Secondary" Variant="Variant.Outlined" OnClick="ResetGame">Reset</MudButton>
    </div>

    @if (_eggReady && !EasterEggService.IsEasterEggCompleted)
    {
        <div class="mt-2 d-flex justify-content-start">
            <MudButton Color="Color.Success" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Celebration" OnClick="OpenEasterEggAsync">
                Easter Egg öffnen
            </MudButton>
        </div>
    }
</MudPaper>

@code {
    private const double BoardWidth = 760;
    private const double BoardHeight = 420;
    private const double PaddleWidth = 140;
    private const double PaddleHeight = 14;
    private const double PaddleYOffset = 18;
    private const double BallSize = 14;
    private const double PaddleSpeed = 6;
    private const int RequiredScore = 6;

    private readonly Random _rng = new();
    private CancellationTokenSource? _loopCts;
    private ElementReference _boardRef;

    private double _paddleX = (BoardWidth - PaddleWidth) / 2;
    private double _ballX;
    private double _ballY;
    private double _ballVx;
    private double _ballVy;
    private bool _eggReady;
    private bool _moveLeft;
    private bool _moveRight;

    protected override void OnInitialized()
    {
        ResetBall(resetScore: true);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            StartLoop();
            await FocusBoard();
        }
    }

    private void StartLoop()
    {
        _loopCts?.Cancel();
        _loopCts = new CancellationTokenSource();
        _ = RunLoopAsync(_loopCts.Token);
    }

    private async Task RunLoopAsync(CancellationToken token)
    {
        var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(16));
        try
        {
            while (await timer.WaitForNextTickAsync(token))
            {
                if (Running)
                {
                    Step();
                    await InvokeAsync(StateHasChanged);
                }

            }
        }
        catch (OperationCanceledException)
        {
            // loop stopped
        }
    }

    private void Step()
    {
        ApplyPaddleMovement();

        _ballX += _ballVx;
        _ballY += _ballVy;

        if (_ballX <= 0)
        {
            _ballX = 0;
            _ballVx = Math.Abs(_ballVx);
        }
        else if (_ballX + BallSize >= BoardWidth)
        {
            _ballX = BoardWidth - BallSize;
            _ballVx = -Math.Abs(_ballVx);
        }

        if (_ballY <= 0)
        {
            _ballY = 0;
            _ballVy = Math.Abs(_ballVy);
        }

        var paddleY = BoardHeight - PaddleHeight - PaddleYOffset;
        if (_ballY + BallSize >= paddleY)
        {
            if (_ballX + BallSize >= _paddleX && _ballX <= _paddleX + PaddleWidth)
            {
                _ballY = paddleY - BallSize;
                var hitFactor = ((_ballX + BallSize / 2) - (_paddleX + PaddleWidth / 2)) / (PaddleWidth / 2);
                _ballVy = -(Math.Abs(_ballVy) + 0.25);
                _ballVx += hitFactor * 2.0;
                KeepVelocityInBounds();

                Score++;
                _eggReady = Score >= RequiredScore && !EasterEggService.IsEasterEggCompleted;
            }
            else
            {
                MissBall();
            }
        }
        else if (_ballY + BallSize >= BoardHeight)
        {
            MissBall();
        }
    }

    private void MissBall()
    {
        Score = Math.Max(0, Score - 1);
        Running = false;
        ResetBall(resetScore: false);
    }

    private void ResetBall(bool resetScore)
    {
        if (resetScore)
        {
            Score = 0;
        }

        _paddleX = (BoardWidth - PaddleWidth) / 2;
        _ballX = (BoardWidth - BallSize) / 2;
        _ballY = BoardHeight * 0.35;
        _ballVx = (_rng.Next(0, 2) == 0 ? -1 : 1) * 3.4;
        _ballVy = 3.0;
        _eggReady = Score >= RequiredScore && !EasterEggService.IsEasterEggCompleted;
    }

    private void KeepVelocityInBounds()
    {
        var maxSpeed = 8.0;
        if (_ballVx > maxSpeed) _ballVx = maxSpeed;
        if (_ballVx < -maxSpeed) _ballVx = -maxSpeed;

        var minVy = 2.4;
        if (_ballVy < -minVy) return;
        _ballVy = -minVy;
    }

    private async Task OpenEasterEggAsync()
    {
        if (!_eggReady || EasterEggService.IsEasterEggCompleted) return;
        Running = false;
        _eggReady = false;
        ResetBall(resetScore: false);

        EasterEggService.MarkEasterEggCompleted();

        var options = new DialogOptions
        {
            FullWidth = true,
            MaxWidth = MaxWidth.Medium
        };

        await DialogService.ShowAsync<EasterEggDialog>("Gluecksrad", options);
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft":
            case "a":
            case "A":
                _moveLeft = true;
                break;
            case "ArrowRight":
            case "d":
            case "D":
                _moveRight = true;
                break;
            case " ":
            case "Spacebar":
                StartGame();
                break;
        }
        await FocusBoard();
    }

    private void OnKeyUp(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft":
            case "a":
            case "A":
                _moveLeft = false;
                break;
            case "ArrowRight":
            case "d":
            case "D":
                _moveRight = false;
                break;
            default:
                break;
        }
    }

    private void ApplyPaddleMovement()
    {
        if (_moveLeft) MovePaddle(-1);
        if (_moveRight) MovePaddle(1);
    }

    private void MovePaddle(int direction)
    {
        _paddleX += direction * PaddleSpeed;
        var max = BoardWidth - PaddleWidth;
        if (_paddleX < 0) _paddleX = 0;
        if (_paddleX > max) _paddleX = max;
    }

    private async Task FocusBoard()
    {
        try { await _boardRef.FocusAsync(); } catch { }
    }

    private void StartGame()
    {
        Running = true;
    }

    private void PauseGame()
    {
        Running = false;
    }

    private void ResetGame()
    {
        Running = false;
        ResetBall(resetScore: true);
    }

    private string GetBallStyle()
    {
        var x = _ballX.ToString(CultureInfo.InvariantCulture);
        var y = _ballY.ToString(CultureInfo.InvariantCulture);
        return $"width:{BallSize}px;height:{BallSize}px;transform: translate({x}px, {y}px);";
    }

    private string GetPaddleStyle()
    {
        var y = BoardHeight - PaddleHeight - PaddleYOffset;
        var x = _paddleX.ToString(CultureInfo.InvariantCulture);
        var yStr = y.ToString(CultureInfo.InvariantCulture);
        return $"width:{PaddleWidth}px;height:{PaddleHeight}px;transform: translate({x}px, {yStr}px);";
    }

    private string StatusText => EasterEggService.IsEasterEggCompleted ? "Easter Egg gefunden" : Running ? "Laeuft" : "Bereit";

    private bool Running { get; set; }

    private int Score { get; set; }

    public void Dispose()
    {
        _loopCts?.Cancel();
    }
}

<style>
    .pong-card {
        background: linear-gradient(145deg, rgba(12, 33, 51, 0.08), rgba(7, 105, 173, 0.07));
        border: 1px solid rgba(0, 0, 0, 0.04);
    }

    .pong-board {
        position: relative;
        width: 100%;
        max-width: 820px;
        height: 420px;
        margin: 0 auto;
        border-radius: 12px;
        background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.08), transparent 35%), radial-gradient(circle at 80% 10%, rgba(255, 255, 255, 0.06), transparent 40%), linear-gradient(180deg, rgba(10, 29, 48, 0.25), rgba(8, 21, 36, 0.35));
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04), 0 10px 30px rgba(0, 0, 0, 0.25);
        overflow: hidden;
        outline: none;
    }

    .pong-net {
        position: absolute;
        left: 50%;
        top: 0;
        bottom: 0;
        width: 2px;
        background: repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.4) 8px, transparent 8px, transparent 16px);
        transform: translateX(-50%);
        opacity: 0.4;
    }

    .pong-ball {
        position: absolute;
        top: 0;
        left: 0;
        background: radial-gradient(circle at 30% 30%, #fff, #f2f3f5 55%, #cdd5e2);
        border-radius: 50%;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
        will-change: transform;
        transition: transform 16ms linear;
    }

    .pong-paddle {
        position: absolute;
        top: 0;
        left: 0;
        background: linear-gradient(90deg, #0d6efd, #0b5ed7);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
        will-change: transform;
        transition: transform 16ms linear;
    }

    .pong-hint {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, rgba(8, 12, 20, 0.6), rgba(8, 12, 20, 0.3));
        color: white;
        text-align: center;
        letter-spacing: 0.3px;
    }
</style>
